# 基础篇

## 从复杂度开始认识算法

### 如何学习数据结构

- 数据结构 = 结构定义 + 结构操作（学习数据结构的重点）
- 数据结构就是定义一种性质，并且维护这种性质（使用数据结构的重点）
- 数据结构不是背的，而是设计出来的
- 比代码实现的基本数据结构更重要的是学会将实际问题抽象成逻辑上的数据结构

__学习，学细节__;__使用，用性质。__

### 如何学习算法

**学习，学流程，学正确性**;**使用，用输出。**

### 如何确定程序中的BUG

**先沿着算法逻辑，检查数据处理流程是否有问题；再检查程序中每个阶段的数据是否符合预期。**（接着按照这个方法层层深入检查）

### 复杂度

**复杂度是程序最重要的一项审美标准。**

- 时间复杂度：吃得多不多，反映了程序运行时间与问题规模之间的变化关系
- 空间复杂度：跑得快不快，反映了程序所需空间与问题规模之间的变化关系
- 时间换空间，空间换时间

**系数归一，常数归一，保留最高次项。**

## 递归函数设计技巧

### 结构归纳法

- 验证p(1)成立
- 证明如果p(k)成立，那么p(k + 1)也成立
- 联合以上两点，证明p(1)=>p(n)成立

### 递归函数设计的三个重要部分

- **重要**：给递归函数一个**明确**的语义信息
- 实现边界条件的程序逻辑
- 假设递归函数调用返回结果是正确的，实现本层函数逻辑

## 顺序表与链表

### 顺序表

```c
代码示例：
//结构定义
typedef struct vector {
    int size, count;
    int *data;
} vector;

//结构操作
vector *getNewVector(int n) {
    vector *p = (vector *)malloc(sizeof(vector));
    p->size = n;
    p->count = 0;
    p->data = (int *)malloc(sizeof(int) * n);
    return p;
}

void clear(vector *v) {
    if (v == NULL) return ;
    free(v->data);
    free(v);
    return ;
}

int expand(vector *v) {
    if (v == NULL) return 0;
    printf("expand v from %d to %d\n", v->size, 2 * v->size);
    int *p = (int *)realloc(v->data, sizeof(int) * 2 * v->size);
    if (p == NULL) return 0;
    v->data = p;
    v->size *= 2;
    return 1;
}

int insert(vector *v, int pos, int val) {
    if (pos < 0 || pos > v->count) return 0;
    if (v->size == v->count && !expand(v)) return 0;
    for (int i = v->count - 1; i >= pos; i--) {
        v->data[i + 1] = v->data[i];
    }
    v->data[pos] = val;
    v->count += 1;
    return 1;
}

int erase(vector *v, int pos) {
    if (v == NULL) return 0;
    if (pos < 0 || pos >= v->count) return 0;
    for (int i = pos + 1; i < v->count; i++) {
        v->data[i - 1] = v->data[i];
    }
    v->count -= 1;
    return 1;
}
```

### 链表

**分清程序内部和内存内部。**

```c
代码示例：
//结构定义
typedef struct Node {
    int data;
    struct Node *next;
} Node;

//结构操作
Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->next = NULL;
    return p;
}

Node *insert(Node *head, int pos, int val) {
    Node new_head, *p = &new_head, *node = getNewNode(val);
    new_head.next = head;
    for (int i = 0; i < pos; i++) p = p->next;
    node->next = p->next;
    p->next = node;
    return new_head.next;
} //有头链表

void clear(Node *head) {
    if (head == NULL) return ;
    for (Node *p = head, *q; p; p = q) {
        q = p->next;
        free(p);
    }
    return ;
}
```

单向循环链表的头指针head指向最后一个结点，可使最后一个结点起到虚拟头结点的作用。

#### 链表翻转及进阶

```c
//头插法实现链表翻转
ListNode* reverseList(ListNode* head) {
    ListNode new_head, *p = head, *q;
    new_head.next = NULL;
    while (p) {
        q = p->next;
        p->next = new_head.next;
        new_head.next = p;
        p = q;
    }
    return new_head.next;
}
```

```c
//递归实现链表翻转
ListNode* reverseList(ListNode* head) {
    if (head == NULL || head->next == NULL) return head;
    ListNode *tail = head->next;
    ListNode *new_head = reverseList(head->next)
    head->next = tail->next;
    tail->next = head;
    return new_head;
}
```

```c
//递归实现链表从left到right结点的翻转
ListNode* reverseBetween(ListNode* head, int left, int right) {
    if (left == 1 && right == 1) return head;
    if (left != 1) {
        head->next = reverseBetween(head->next, left - 1, right - 1);
    } else {
        ListNode *tail = head->next, *new_head;
        new_head = reverseBetween(head->next, left, right - 1);
        head->next = tail->next;
        tail->next = head;
        head = new_head;
    }
    return head;
}
```

可使用快慢指针判断链表是否有环。

#### 双指针等距移动法

让指针p指向链表倒数第n个结点的技巧：初始时指针p, q都指向头结点，然后指针q向后移动指向第n - 1个结点，接着指针p, q同时等距向后移动，当指针q指向空时，指针p指向的即为链表倒数第n个结点。

## 栈和队列

**注意数据结构之间的相互封装，基础数据结构是实现高级数据结构的基础，这不仅体现在思维上，也体现在底层实现上。**

### 队列

性质：`FIFO`（先进先出）

#### 顺序表实现

```c
typedef struct vector {
    int size;
    int *data;
} vector;

vector *initVector(int n) {
    vector *v = (vector *)malloc(sizeof(vector));
    v->data = (int *)malloc(sizeof(int) * n);
    v->size = n;
    return v;
}

int vectorSeek(vector *v, int pos) {
    if (pos < 0 || pos >= v->size) return -1;
    return v->data[pos];
}

int insertVector(vector *v, int pos, int val) {
    if (pos < 0 || pos >= v->size) return 0;
    v->data[pos] = val;
    return 1;
}

void clearVector(vector *v) {
    if (v == NULL) return ;
    free(v->data);
    free(v);
    return ;
}

typedef struct Queue {
    vector *data;
    int size, head, tail, count;
} Queue;

Queue *initQueue(int n) {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->data = initVector(n);
    q->size = n;
    q->head = q->tail = q->count = 0;
    return q;
}

int empty(Queue *q) {
    return q->count == 0;
}

int front(Queue *q) {
    return vectorSeek(q->data, q->head);
}

int push(Queue *q, int val) {
    if (q->count == q->size) return 0;
    insertVector(q->data, q->tail, val);
    q->tail += 1;
    if (q->tail == q->size) q->tail = 0;
    q->count += 1;
    return 1;
}

int pop(Queue *q) {
    if (empty(q)) return 0;
    q->head += 1;
    if (q->head == q->size) q->head = 0;
    q->count -= 1;
    return 1;
}

void clearQueue(Queue *q) {
    if (q == NULL) return ;
    clearVector(q->data);
    free(q);
    return ;
}
```

#### 链表实现

```c
typedef struct Node {
    int data;
    Node *next;
} Node;

typedef struct Linklist {
    Node head, *tail;
} Linklist;

Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->next = NULL;
    return p;
}

Linklist *initLinklist() {
    Linklist *l = (Linklist *)malloc(sizeof(Linklist));
    l->head.next = NULL;
    l->tail = &(l->head);
    return l;
}

void clearLinklst(Linklist *l) {
    Node *p = l->head.next, *q;
    while (p) {
        q = p->next;
        free(p);
        p = q;
    }
    free(l);
    return ;
}

typedef struct Queue {
    Linklist *l;
    int count;
} Queue;

Queue *initQueue() {
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->l = initLinklist();
    q->count = 0;
    return q;
}

int emptyList(Linklist *l) {
    return l->head.next == NULL;
}

int frontList(Linklist *l) {
    if (emptyList(l)) return 0;
    return l->head.next->data;
}

int insertTail(Linklist *l, int val) {
    Node *node = getNewNode(val);
    l->tail->next = node;
    l->tail = node;
    return 1;
}

int eraseHead(Linklist *l) {
    if (emptyList(l)) return 0;
    Node *p = l->head.next;
    l->head.next = l->head.next->next;
    if (p == l->tail) l->tail = &(l->head);
    free(p);
    return 1;
}

int empty(Queue *q) {
    return q->count == 0;
}

int front(Queue *q) {
    if (empty(q)) return 0;
    return frontList(q->l);
}

int push(Queue *q, int val) {
    insertTail(q->l, val);
    q->count += 1;
    return 1;
}

int pop(Queue *q) {
    eraseHead(q->l);
    q->count -= 1;
    return 1;
}

void clearQueue(Queue *q) {
    if (q == NULL) return ;
    clearLinklst(q->l);
    free(q);
    return ;
}
```

### 栈

性质：`FILO`（先进后出）

#### 数组实现

```c
typedef struct Stack {
    int *data;
    int size, top;
}Stack;

Stack *initStack(int n) {
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s->data = (int *)malloc(sizeof(int) * n);
    s->size = n;
    s->top = -1;
    return s;
}

int empty(Stack *s) {
    return s->top == -1;
}

int top(Stack *s) {
    if (empty(s)) return 0;
    return s->data[s->top];
}

int push(Stack *s, int val) {
    if (s->top + 1 == s->size) return 0;
    s->top += 1;
    s->data[s->top] = val;
    return 1;
}

int pop(Stack *s) {
    if (empty(s)) return 0;
    s->top -= 1;
    return 1;
}

void clearStack(Stack *s) {
    if (s == NULL) return ;
    free(s->data);
    free(s);
    return ;
}
```

#### 括号匹配

```c
void slove(char str[]) {
    int flag = 1;
    Stack *s = initStack(100);
    for (int i = 0; str[i]; i++) {
        if (str[i] == '(' || str[i] == '[' || str[i] == '{') {
            push(s, str[i]);
        } else {
            switch (str[i]) {
                case ')': {
                    if (!empty(s) && top(s) == '(') pop(s);
                    else flag = 0;
                } break;
                case ']': {
                    if (!empty(s) && top(s) == '[') pop(s);
                    else flag = 0;
                } break;
                case '}': {
                    if (!empty(s) && top(s) == '{') pop(s);
                    else flag = 0;
                } break;
            }
            if (flag == 0) break;
        }
    }
    if (flag == 0 || !empty(s)) {
        printf("error : %s\n", str);                                   
    } else {
        printf("success : %s\n", str);
    }
    clearStack(s);
    return ;
}
```

#### 栈的深入理解

假设只有一种括号：

- 任意位置左括号数量 >=右括号数量
- 最后位置左括号数量==右括号数量
- 程序中只需记录左右括号数量即可

进一步

- 遇到左括号左括号数量+1，遇到右括号左括号数量-1，等价于栈顶指针的移动
- 任意位置左括号数量>=0，最后位置左括号数量=0
- 只需记录左括号数量即可

再进一步

- +1等价于**进**，-1等价于**出**
- 进等价于**事件发生**，出等价于**事件解决**
- 一对()等价于一个完整的事件
- (())看作事件与事件之间的完全包含关系，例如**程序的执行过程**
- 由括号的等价变换，得到了一个新的数据结构

**栈可以处理具有完全包含关系的问题。**

### 栈和队列的应用

- 栈：树的深度遍历、深度优先搜索
- 队列（循环）：树的层序（广度）遍历、广度优先搜索
- 单调栈：临近最大（小）值
- 单调队列：区间最大（小）值

## 树与二叉树

### 树结构深入理解

树的结点代表**集合**，树的边代表**关系**（根结点代表全集）。

树的深度遍历(后序遍历)可以判断两个结点是否是父子关系（利用栈处理具有完全包含关系的问题）。

```C
int tot = 0;
void dfs(Node *root) {
    if (root == NULL) return ;
    int start, end;
    tot += 1;
    start = tot;
    if (root->lchild) dfs(root->lchild);
    if (root->rchild) dfs(root->rchild);
    tot -= 1;
    end = tot;
    printf("%d : [%d, %d]\n", root->key, start, end);
    return ;
}
```

### 二叉树

度为0的结点比度为2的结点多一个。

满二叉树的定义为没有度为1的结点，完美二叉树的定义为每一层都是满的（有些中文资料中把这两种二叉树搞混了）。

完全二叉树

- 编号为i的结点，左孩子编号2 * i，右孩子编号2 * i+ 1
  - 用父结点计算得到子结点地址（时间换空间）
- 可以用连续空间存储（数组）

利用左孩子右兄弟表示法将k叉树转换为二叉树可大量节省空间。

### 二叉树的遍历与线索化

遍历是通过递归实现的，左、右表示的是左、右子树对应遍历方式的结果。

无法通过前序遍历和后续遍历确定二叉树的原因：无法确定左右子树的结点数量。

二叉树的遍历的作用：

- 完成二叉树的序列化（将二叉树的信息通过网络从一台计算机有效的传输给另一台计算机，并且恢复相应的数据结构）

线索化即废物利用。

二叉树的线索化的作用：将二叉树的遍历方式从递归转化为非递归，使其遍历表现得像链表。

```c
typedef struct Node {
    int key;
    int ltag, rtag; // 1 : thread, 0 : edge
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->ltag = p->rtag = 0;
    p->lchild = p->rchild = NULL;
    return p;
}

Node *insert(Node *root, int key) {
    if (root == NULL) return getNewNode(key);
    if (rand() % 2) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    return root;
}

void clear(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == 0) clear(root->lchild);
    if (root->rtag == 0) clear(root->rchild);
    free(root);
    return ;
}

void pre_order(Node *root) {
    if (root == NULL) return ;
    printf("%d ", root->key);
    if (root->ltag == 0) pre_order(root->lchild);
    if (root->rtag == 0) pre_order(root->rchild);
    return ;
}

void in_order(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == 0) in_order(root->lchild);
    printf("%d ", root->key);
    if (root->rtag == 0) in_order(root->rchild);
    return ;
}

void post_order(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == 0) post_order(root->lchild);
    if (root->rtag == 0) post_order(root->rchild);
    printf("%d ", root->key);
    return ;
}

Node *pre_node = NULL, *inorder_root = NULL;
void __build_inorder_thread(Node *root) {
    if (root == NULL) return ;
    if (root->ltag == 0) __build_inorder_thread(root->lchild);
    if (inorder_root == NULL) inorder_root = root;
    if (root->lchild == NULL) {
        root->lchild = pre_node;
        root->ltag = 1;
    }
    if (pre_node && pre_node->rchild == NULL) {
        pre_node->rchild = root;
        pre_node->rtag = 1;
    }
    pre_node = root;
    if (root->rtag == 0) __build_inorder_thread(root->rchild);
    return ;
}

// 封装处理最后一个结点的线索化
void build_inorder_thread(Node *root) {
    __build_inorder_thread(root);
    pre_node->rchild = NULL;
    pre_node->rtag = 1;
    return ;
}

Node *getNext(Node *root) {
    if (root->rtag == 1) return root->rchild;
    root = root->rchild;
    while (root->ltag == 0 && root->lchild) root = root->lchild;
    return root;
}
```

__代码设计中，没有什么是封装解决不了的。__

### 二叉树与广义表

- ():空树
- A / A():根结点为A，无左右子树
- A(B,) / A(B):根结点为A，左子树为B，无右子树（如果只有右子树逗号不可省略）
- A(B,C):根结点为A，左子树为B，右子树为C

#### 二叉树转广义表

- 利用先序遍历代码框架
- 利用`sprintf`将二叉树信息转换为字符串

```c
char buff[1000];
int len = 0;

void __serialize(Node *root) {
    if (root == NULL) return ;
    len += snprintf(buff + len, 100, "%d", root->key);
    if (root->lchild == NULL && root->rchild == NULL) return ;
    len += snprintf(buff + len, 100, "(");
    __serialize(root->lchild);
    if (root->rchild) {
        len += snprintf(buff + len, 100, ",");
        __serialize(root->rchild);
    }
    len += snprintf(buff + len, 100, ")");
    return ;
}

void serialize(Node *root) {
    memset(buff, 0, sizeof(buff));
    len = 0;
    __serialize(root);
    return ;
}
```

#### 广义表转二叉树

分析：具有完全包含关系==>栈

算法思路

- 设置标记：说明当前处理的为左/右子树

- 遇到关键字：生成新结点
- 遇到（：将刚生成的新结点压栈，并标记当前处理的为左子树
- 遇到，：标记当前处理的为右子树
- 遇到）：将栈顶结点出栈
- 每生成结点：根据标记设置为栈顶元素的左/右子树

```c
Node *deserialize(char *buff, int n) {
    Node **s = (Node **)malloc(sizeof(Node *) * MAX_NODE); //用数组模拟栈
    int top = -1, flag = 0, scode = 0; // scode为状态码
    Node *p = NULL, *root = NULL; // p指向最新生成的结点
    for (int i = 0; buff[i]; i++) {
        switch (scode) {
            case 0: {
                if (buff[i] >= '0' && buff[i] <= '9') scode = 1;
                else if (buff[i] == '(') scode = 2;
                else if (buff[i] == ',') scode = 3;
                else scode = 4;
                i -= 1; // case 0未作任何处理，抵消外层循环i + 1
            } break; //根据当前状态作任务分发
            case 1 : {
                int key = 0;
                while (buff[i] <= '9' && buff[i] >= '0') {
                    key = key * 10 + (buff[i] - '0');
                    i += 1;
                }
                p = getNewNode(key);
                if (top >= 0 && flag == 0) s[top]->lchild = p;
                if (top >= 0 && flag == 1) s[top]->rchild = p;
                i -= 1; // 抵消外层循环i + 1
                scode = 0; //分发完任务后继续分发下一个任务
            } break;
            case 2 : {
                s[++top] = p;
                flag = 0;
                scode = 0;
            } break;
            case 3 : {
                flag = 1;
                scode = 0;
            } break;
            case 4 : {
                root = s[top];
                top -= 1;
                scode = 0;
            } break;
        } // 参考状态机的编码技巧
    }
    return root;
}
```

序列化和反序列化的过程实际上是信息等价变换的过程。

__算法设计过程:__

- 确定大的算法思维框架
- 根据具体问题完善框架的细节

### 哈夫曼编码

 定长编码可以看成特殊的变长编码（实际上当各个字符等概率出现时，其对应的哈夫曼编码即为定长编码）。

字符均为哈夫曼树的叶子结点保证了各编码之间不构成前缀关系。

```c
Node *buildHaffmanTree(Node **node_arr, int n) {
    for (int i = 1; i < n; i++) {
        // find two node
        int ind1 = find_min_node(node_arr, n - i); //选择排序
        swap_node(node_arr, ind1, n - i);
        int ind2 = find_min_node(node_arr, n - i - 1);
        swap_node(node_arr, ind2, n - i - 1);
        // merge two node 
        int freq = node_arr[n - i]->freq + node_arr[n - i - 1]->freq;
        Node *node = getNewNode(freq, 0);
        node->lchild = node_arr[n - i - 1];
        node->rchild = node_arr[n - i];
        node_arr[n - i - 1] = node;
    }
    return node_arr[0];
}

#define MAX_CHAR_NUM 128
char *char_code[MAX_CHAR_NUM] = {0};

void extractHaffmanCode(Node *root, char buff[], int k) {
    buff[k] = 0;
    if (root->lchild == NULL && root->rchild == NULL) {
        char_code[root->ch] = strdup(buff); //类似桶排序的思想，按字典序输出
        return ;
    }
    buff[k] = '0';
    extractHaffmanCode(root->lchild, buff, k + 1);
    buff[k] = '1';
    extractHaffmanCode(root->rchild, buff, k + 1); 
    return ;
}
```

## 堆与优先队列

__学习数据结构最有价值的是学习数据结构的思维逻辑结构。__

| 普通队列 |        堆：优先队列         |
| :------: | :-------------------------: |
| 尾部入队 |        尾部可以插入         |
| 头部出队 |        头部可以弹出         |
| 先进先出 | 每次出队权值最大/最小的元素 |
| 数组实现 | 数组实现，逻辑上看成一个堆  |

```C
typedef struct PriorityQueue {
    int *__data, *data;
    int size, n;
} PriorityQueue;

PriorityQueue *initPQ(int size) {
    PriorityQueue *p = (PriorityQueue *)malloc(sizeof(PriorityQueue));
    p->__data = (int *)malloc(sizeof(int) * size);
    p->data = p->__data - 1; //编程技巧，下标偏移，使data + 1指向的即为__data处，便于计算孩子结点的下标
    p->size = size;
    p->n = 0;
    return p;
}
```

__堆的深入理解：维护集合最值。可利用对顶堆维护中位数。__

### 向上调整与向下调整

```c
void up_update(int *data, int i) {
    while (i > 1 && data[i] cmp data[FATHER(i)]) {
        swap(data[i], data[FATHER(i)]);
        i = FATHER(i);
    }
    return ;
}
```

```c
void down_update(int *data, int i, int n) {
    while (LEFT(i) <= n) {
        int ind = i, l = LEFT(i), r = RIGHT(i);
        if (data[l] cmp data[ind]) ind = l;
        if (r <= n && data[r] cmp data[ind]) ind = r;
        if (ind == i) break;
        swap(data[i], data[ind]);
        i = ind;
    }
    return ;
}
```

### 堆排序与线性建堆法

#### 堆排序

- 原地排序

- 将堆顶元素与堆尾元素交换
- 将此操作看做是堆顶元素弹出操作
- 按照头部弹出以后的策略调整堆

```C
void heap_sort_final(int *data, int n) {
    for (int i = n; i >= 2; i--) {
        swap(data[i], data[1]);
        down_update(data, 1, i - 1);
    }
    return ;
}
```

#### 线性建堆：向下调整

- 普通建堆：插入到最后然后向上调整

- 先按原顺序构建二叉树，然后每轮从最后一个非叶子结点开始依次调整，直到无需调整为止
- 时间复杂度为O(n)
  - n / 2个结点有孩子
  - n / 4个结点要处理1次，n / 8个结点要处理2次......n / n个结点要处理log<sub>2</sub>n次

```C
void linear_heap_build(int *data, int n) {
    for (int i = n / 2; i >= 1; i--) {
        down_update(data, i, n);
    }
    return ;
}
```

### 优化：哈夫曼编码

- 利用堆得到频率最小的两个结点
- 建树的时间复杂度由O(n<sup>2</sup>)变为O(`nlogn`)

```C
Node *buildHaffmanTree(Node **node_arr, int n) {
    Heap *h = getNewHeap(n);
    for (int i = 0; i < n; i++) pushHeap(h, node_arr[i]);
    for (int i = 1; i < n; i++) {
        Node *node1 = top(h);
        popHeap(h);
        Node *node2 = top(h);
        popHeap(h);
        Node *node3 = getNewNode(node1->freq + node2->freq, 0);
        node3->lchild = node1;
        node3->rchild = node2;
        pushHeap(h, node3);
    }
    Node *ret = top(h);
    clearHeap(h);
    return ret;
}
```

### 用set模拟堆

- `set<type> s`定义元素类型为type的集合s
- `s.insert()`插入
- `s.size()`表示集合大小

- 元素具有去重性

- 利用`pair<type,type>`可将两个type数据类型打包为一个数据类型，可以规定第一个type为原数值，第二个type为存入的顺序，从而实现具有重复元素的集合

- ```C
  for (auto x : s) { // x依次遍历s集合中的所有元素
       cout << "(" << x.first << ", " << x.second << ")" << endl; 
  } // 集合遍历的顺序是按集合中所存储值的大小遍历
  ```

- ```C
  for (int i = 0; i < 4; i++) {
      cout << "s.begin() = " << s.begin()->first << endl; 
      // s.begin是指向第一个元素的迭代器，通过s.begin访问集合中的第一个元素，即最小值；top
      s.erase(s.begin()); // pop
  } // set天生就是小顶堆，而要用set模拟大顶堆，可以将集合中的元素全部取相反数后再存入集合中,取出元素时再取反即可(其他方法涉及C++)
  ```


## 排序算法

### 选择排序

- 平均执行次数：n * (n + 1) / 2
- 时间复杂度
  - 最好：O(n<sup>2</sup>)
  - 平均：O(n<sup>2</sup>)
  - 最坏：O(n<sup>2</sup>)

```C
void selection_sort(int *arr, int l, int r) {
    for (int i = l, I = r - 1; i < I; i++) {
        int ind = i;
        for (int j = i + 1; j < r; j++) {
            if (arr[j] < arr[ind]) ind = j;
        }
        swap(arr[i], arr[ind]);
    }
    return; 
} 
```

### 插入排序

- 平均执行次数：n * (n + 1) / 4
  - 虽然理论上比选择排序少，但由于交换操作相较于数组遍历更费时(CPU将内存调入cache时按块调入)，故实际运行时间未必比选择排序少。
- 时间复杂度
  - 最好：O(n)
  - 平均：O(n<sup>2</sup>)
  - 最坏：O(n<sup>2</sup>)

```C
void insert_sort(int *arr, int l, int r) {
    for (int i = l + 1; i < r; i ++) {
        int j = i;
        while (j > l && arr[j] < arr[j - 1]) {
            swap(arr[j], arr[j - 1]);
            j -= 1;
        }
    }
    return ;
}
```

```C
void unguarded_insert_sort(int *arr, int l, int r) {
    int ind = l;
    for (int i = l + 1; i < r; i++) {
        if (arr[i] < arr[ind]) ind = i;
    } // 增加了O(n)
    while(ind > l) {
        swap(arr[ind], arr[ind - 1]);
        ind -= 1;
    } // 平移而不直接交换保证插入排序的稳定性
    for (int i = l + 1; i < r; i++) {
        int j = i;
        while (arr[j] < arr[j - 1]) {
            swap(arr[j], arr[j - 1]) ; // 初始逆序数O(n2)，每执行一次逆序数减1
            j -= 1;
        }
    } // j > l的判断次数相当于交换次数，故减少了O(n2)
    return ;
}
```

### 希尔排序

- 设计一个步长序列
- 按照步长，对序列进行分组，每组采用插入排序
- 直到执行步长为1为止
- 效率和步长序列紧密相关，参考时间复杂度：O(`nlogn`) ~O(n<sup>2</sup>)
- 增量序列
  - 希尔增量序列：n/2, n/4, n/8, n/16......, 最坏时间复杂度：O(n<sup>2</sup>)
  - `Hibbard`增量序列：1, 3, 7, ... 2<sup>k</sup>-1, 最坏时间复杂度：O(n<sup>1.5</sup>)

- 希尔排序效率高的原因：分组之后，经过几轮插入排序，每个元素向前找一定数量的元素之后即可找到比其小的元素，这样的序列对插入排序非常友好

```C
void shell_sort(int * arr, int l, int r) {
    int k = 2, n = (r - l), step;
    do {
        step = n / k == 0 ? 1 : n / k;
        for (int i = l, I = l + step; i < I; i++) {
            unguarded_insert_sort(arr, i, r, step);
        }
        k *= 2;
    } while (step != 1);
    return ;
}

void shell_sort_hibbard(int *arr, int l, int r) {
    int step = 1, n = (r - l);
    while (step <= n / 2) step = step * 2 + 1;
    do {
        step /= 2;
        for (int i = l, I = l + step; i < I; i++) {
            unguarded_insert_sort(arr, i, r, step);
        }   
    } while (step > 1);
    return ;
}
```

### 冒泡排序

时间复杂度

- 最好：O(n)
- 平均：O(n<sup>2</sup>)
- 最坏：O(n<sup>2</sup>)

```c
void bubble_sort(int *arr, int l, int r) {
    for (int i = r - 1, I = l + 1, flag; i >= I; i--) {
        flag = 0;
        for (int j = l; j < i; j++) {
            if (arr[j] <= arr[j + 1]) continue;
            swap(arr[j], arr[j + 1]);
            flag = 1;
        }
        if (flag == 0) break;
    }
    return ;
} 
```

### 快速排序

- 时间复杂度
  - 最好：O(`nlogn`)
  - 平均：O(`nlogn`)
  - 最坏：O(n<sup>2</sup>)

```C
void quick_sort(int *arr, int l, int r) {
    if (r - l <= 2) {
        if (r - l <= 1) return ;
        if (arr[l] > arr[l + 1]) swap(arr[l], arr[l + 1]);
        return ;
    }
    // partition
    int x = l, y = r - 1, z = arr[l];
    while (x < y) {
        while (x < y && z <= arr[y]) --y;
        if (x < y) arr[x++] = arr[y];
        while (x < y && arr[x] <= z) ++x;
        if (x < y) arr[y--] = arr[x];
    }
    arr[x] = z;
    quick_sort(arr, l, x);
    quick_sort(arr, x + 1, r);
    return ;
}

void quick_sort_v1(int *arr, int l, int r) {
    if (r - l <= 2) {
        if (r - l <= 1) return ;
        if (arr[l] > arr[l + 1]) swap(arr[l], arr[l + 1]);
        return ;
    }
    // partition
    int x = l, y = r - 1, z = arr[l];
    do {
        while (arr[x] < z) ++x;
        while (arr[y] > z) --y;
        if (x <= y) {
            swap(arr[x], arr[y]);
            ++x, --y;
        }
    } while (x <= y);
    quick_sort_v1(arr, l, x);
    quick_sort_v1(arr, x, r);
    return ;
} // 优化1：减少比较次数

int three_point_select(int a, int b, int c) {
    if (a > b) swap(a, b);
    if (a > c) swap(a, c);
    if (b > c) swap(b, c);
    return b; 
}

void quick_sort_v2(int *arr, int l, int r) {
    if (r - l <= 2) {
        if (r - l <= 1) return ;
        if (arr[l] > arr[l + 1]) swap(arr[l], arr[l + 1]);
        return ;
    }
    // partition
    int x = l, y = r - 1;
    int z = three_point_select(
        arr[l], 
        arr[r - 1], 
        arr[(l + r) / 2]
    );
    do {
        while (arr[x] < z) ++x;
        while (arr[y] > z) --y;
        if (x <= y) {
            swap(arr[x], arr[y]);
            ++x, --y;
        }
    } while (x <= y);
    quick_sort_v2(arr, l, x);
    quick_sort_v2(arr, x, r);
    return ;
} // 优化2：三点取中法

void quick_sort_v3(int *arr, int l, int r) {
    if (r - l <= 2) {
        if (r - l <= 1) return ;
        if (arr[l] > arr[l + 1]) swap(arr[l], arr[l + 1]);
        return ;
    }
    while (l < r) {
        // partition
        int x = l, y = r - 1;
        int z = three_point_select(
            arr[l], 
            arr[r - 1], 
           arr[(l + r) / 2]
        );
        do {
           while (arr[x] < z) ++x;
           while (arr[y] > z) --y;
            if (x <= y) {
                swap(arr[x], arr[y]);
                ++x, --y;
            }
        } while (x <= y);
        quick_sort_v3(arr, l, x); // left
        l = x; // 在本层函数处理右半部分
    }
    return ;
} // 优化3：单边递归法

#define threshold 16

void unguarded_insert_sort(int *arr, int l, int r) {
    int ind = l;
    for (int i = l + 1; i < r; i++) {
        if (arr[i] < arr[ind]) ind = i;
    }
    while(ind > l) {
        swap(arr[ind], arr[ind - 1]);
        ind -= 1;
    } // 平移而不直接交换保证插入排序的稳定性
    for (int i = l + 1; i < r; i++) {
        int j = i;
        while (arr[j] < arr[j - 1]) {
            swap(arr[j], arr[j - 1]) ; // 每执行一次逆序数减1
            j -= 1;
        }
    }
    return ;
}

void __quick_sort_v4(int *arr, int l, int r) {
    while (r - l > threshold) {
        // partition
        int x = l, y = r - 1;
        int z = three_point_select(
            arr[l], 
            arr[r - 1], 
           arr[(l + r) / 2]
        );
        do {
           while (arr[x] < z) ++x;
           while (arr[y] > z) --y;
            if (x <= y) {
                swap(arr[x], arr[y]);
                ++x, --y;
            }
        } while (x <= y);
        __quick_sort_v4(arr, l, x); // left
        l = x; // 在本层函数处理右半部分
    }
    return ;
} // 优化4：先快排再插入排序

void quick_sort_v4(int *arr, int l, int r) {
    __quick_sort_v4(arr, l, r);
    unguarded_insert_sort(arr, l, r);
    return ;
}
```

### 归并排序

- 过程：分治`->`归并
- 时间复杂度：O(`nlogn`)

```C
int *buff;
void merge_sort(int *arr, int l, int r) {
    if (r - l <= 1) return ;
    int mid = (l + r) / 2;
    merge_sort(arr, l, mid);
    merge_sort(arr, mid, r);
    int p1 = l, p2 = mid, k = 0;
    while (p1 < mid || p2 < r) {
        if (p2 == r || (p1 < mid && arr[p1] <= arr[p2])) {
            buff[k++] = arr[p1++];
        } else {
            buff[k++] = arr[p2++];
        }
    }
    for (int i = l; i < r; i++) arr[i] = buff[i - l];
    return ;
}
```

### 基数排序

原则：相同数字相对位置不变

过程：

- 根据基数对各位计数
  - 选择合适的基数，可减少排序的轮数
  - 对于32位整型，取基数为2<sup>16</sup> = 65536，则只需两轮排序
- 求区域尾坐标，即前缀和
- 归位，转1:从右向左扫描，将每个数字放在数组下标为其对应的前缀和处，然后对应前缀和减一，全部扫描一遍后转一。

时间复杂度：正常来说为O(`nlogm`)，其中m为数据范围，`logm`即排序的轮数；但在整型数据范围内，取基数为65536，理论上可达到O(n)。

```C
void radix_sort(int *arr, int l, int r) {
    #define K 65536
    // 取基数为2的16次方，将每个32位整型分成两部分，则只需两轮排序
    int *cnt = (int *)malloc(sizeof(int) * K); // cnt数组用于统计各部分每种数字出现的次数
    int *temp = (int *)malloc(sizeof(int) * (r - l));
    // round 1
    memset(cnt, 0, sizeof(int) * K);
    for (int i = l; i < r; i++) cnt[arr[i] % K] += 1;
    for (int i = 1; i < K; i++) cnt[i] += cnt[i - 1]; // 求前缀和
    for (int i = r - 1; i >= l; i--) temp[--cnt[arr[i] % K]] = arr[i]; // 归位
    memcpy(arr + l, temp, sizeof(int) * (r - l));
    // round 2
    memset(cnt, 0, sizeof(int) * K);
    for (int i = l; i < r; i++) cnt[arr[i] / K] += 1;
    for (int i = 1; i < K; i++) cnt[i] += cnt[i - 1]; // 求前缀和
    for (int i = r - 1; i >= l; i--) temp[--cnt[arr[i] / K]] = arr[i]; // 归位
    memcpy(arr + l, temp, sizeof(int) * (r - l));  
    return ;
} // 在整型数据范围内，此排序算法的时间复杂度理论上为O(n)
```

思考：如果数据存在负数，以上代码需要如何改写？

### 排序算法总结

__学习任何一个算法都要将其当成一个算法框架学习__

__稳定性__

稳定排序：插入排序、冒泡排序、归并排序、基数排序

非稳定排序：快速排序、选择排序、希尔排序、堆排序

__内外部特性__

内外部特性：排序算法是否可以使用外存，这决定了该算法是否可以对大数据进行排序

内部排序：插入排序、冒泡排序、快速排序、选择排序、希尔排序、堆排序

外部排序：归并排序、基数排序

### C++sort使用方法与技巧

```C
void test1() {
    int *arr = getRandData(10);
    sort(arr, arr + 10); // [)
    sort(arr, arr + 10, greater<int>()); // 从大到小
    free(arr);
    return ;
} // sort array

void test2() {
    vector<int> arr;
    for (int i = 0; i < 10; i++) arr.push_back(rand() % 10000);
    sort(arr.begin(), arr.end());
    sort(arr.begin(), arr.end(), greater<int>());
    return ;
} // sort vector

struct Data {
    int x, y;
} ;

bool cmp(const Data &a, const Data &b) {
    if (a.x != b.x) return a.x < b.x; // a.x < b.x时a排在b前面
    return a.y > b.y; // a.x = b.x, a.y > b.y时a排在b前面
}

void test3() {
    vector<Data> arr;
    for (int i = 0; i < 10; i++) {
        Data d;
        d.x = rand() % 10, d.y = rand() % 10;
        arr.push_back(d);
    }
    sort(arr.begin(), arr.end(), cmp);
    return ;
} // 自建类型排序

void test4() {
    int *arr = getRandData(10);
    int *ind = getRandData(10);
    for (int i = 0; i < 10; i++) ind[i] = i;
    sort(ind, ind + 10, [&](int i, int j) -> bool {
        return arr[i] < arr[j];
    }); // lambda表达式
    return ;
} // 在不改变原数组的情况下排序
```

## 查找算法

### 二分算法

#### 两种泛型情况:

找第一个符合条件的值:

- 注意舍去的一半是否都不符合条件.

- 虚拟尾解决都不符合的特殊情况.

- ```c
  //000000111111 找第一个1(可抽象成找第一个符合条件的值)
  int binary_search1(int *arr, int n) {
      int head = 0, tail = n, mid;//tail指向虚拟尾
      while (head < tail) {
          mid = (head + tail) >> 1;
          if (arr[mid] == 0) head = mid + 1;
          else tail = mid;//注意不是mid - 1
      }
      return head == n ? -1 :head;
  }
  ```

找最后一个符合条件的值:

- 注意舍去的一半是否都不符合条件.

- 上取整解决下取整造成的bug.

- 虚拟头解决都不符合的特殊情况.

- ```c
  //111111000000 找最后一个1(可抽象成最后一个符合条件的值)
  int binary_search2(int *arr,int n) {
      int head = -1, tail = n - 1, mid; //head指向虚拟头
      while (head < tail) {
          mid = (head + tail + 1) >> 1;
          if (arr[mid] == 0) tail = mid - 1;
          else head = mid; //注意不是mid + 1
      }
      return head;
  }
  ```

#### 数组与函数的关系

- 数组
  - 消耗存储资源，即空间
- 函数
  - 消耗计算资源，即时间

__数组和函数本质上都是映射,没有本质区别.__

__函数是压缩的数组,数组是展开的函数.__

__时间换空间，空间换时间.__

__计算机中的计算资源和存储资源在算法层面是没有任何差别的.__

=>二分算法不仅可以应用在有序数组上，还可以应用在单调函数上(由x求y较简单，由y求x较复杂)。

- 所有传入函数的地方都可以用数组代替,所有传入数组参数的位置都可以用函数去进行思维模型的抽象.

- 面对一个算法流程时,如果这个算法流程一开始是通过数组解决问题,说明这个算法流程的数组环节可以改成思维方式更加抽象化的函数去进行更高级的应用.

### 跳跃表(`Skiplist`)

结构定义：

- 在链表的首尾各增加一个结点，分别表示最小值和最大值

- 每一个结点具有不同层高(随机)，处于同一层的结点被串联为一个链表

- 各结点之间有序

  ```C
  typedef struct Node {
      int key, level;
      struct Node *next, *down, *up;
  } Node;
  
  typedef struct Skiplist {
      Node *head, *tail;
      int max_level;
  } Skiplist; // head指向第一个结点的最高层结点地址
  ```

结构操作：

- 创建

  ```C
  Node *getNewNode(int key, int n) {
      Node *nodes = (Node *)malloc(sizeof(Node) * n);
      for (int i = 0; i < n; i++) {
          nodes[i].key = key;
          nodes[i].level = i;
          nodes[i].next = NULL;
          nodes[i].down = (i ? nodes + (i - 1) : NULL);
          nodes[i].up = (i + 1 < n ? nodes + (i + 1) : NULL);
      }
      return nodes + n - 1;
  } // 返回该结点中层号最大的结点地址
  
  Skiplist *getNewSkiplist(int n) {
      Skiplist *s = (Skiplist *)malloc(sizeof(Skiplist));
      s->head = getNewNode(INT32_MIN, n);
      s->tail = getNewNode(INT32_MAX, n);
      s->max_level = n;
      Node *p = s->head, *q = s->tail;
      while (p) {
          p->next = q;
          p = p->down, q = q->down;
      }
      while (s->head->level != 0) s->head = s->head->down;
      return s;
  }
  ```

- 查找
  - 从左上角结点开始
  - 比较当前结点沿链表的下一个结点的值与查找值的大小
  - 若比查找值大，则跳到下一层，转2
  - 若比查找值小，则沿链表跳到下一个结点，转2
  
  ```C
  Node *find(Skiplist *s, int x) {
      Node *p = s->head;
      while (p && p->key != x) {
          if (p->next->key <= x) p = p->next;
          else p = p->down;
      }
      return p;
  }
  ```
  
- 插入
  - 新建结点并随机层高
  - 按查找规则跳跃直到最底层
  - 将上述跳跃过程经过的各层最右侧结点与新结点的各层对应连接
  
  ```C
  int randLevel(Skiplist *s) {
      int level = 1;
      double p = 1.0 / 2.0;
      while (randDouble() < p) level += 1;
  #define min(a, b) ((a) < (b) ? (a) : (b))
      return min(s->max_level, level);
  #undef min
  } // i层的概率为p的(i - 1)次方
  
  void insert(Skiplist *s, int x) {
      int level = randLevel(s);
      while (s->head->level + 1 < level) s->head = s->head->up;
      Node *node = getNewNode(x, level);
      Node *p = s->head;
      fflush(stdout);
      while (p->level != node->level) p = p->down;
      while (p) {
          while (p->next->key < node->key) p = p->next; // 找到插入结点的前一个结点
          node->next = p->next;
          p->next = node;
          p = p->down;
          node = node->down;
      }
      return ;
  }
  ```
  
- 销毁

  ```C
  void clearNode(Node *p) {
      if (p == NULL) return ;
      free(p);
      return ;
  }
  
  void clearSkiplist(Skiplist *s) {
      Node *p = s->head, *q;
      while (p->level != 0) p = p->down;
      while (p) {
          q = p->next;
          clearNode(p);
          p = q;
      }
      free(s);
      return ;
  }
  ```

### 哈希表与布隆过滤器

#### 哈希表

所谓哈希，即从高维空间到低维空间的一种映射。

哈希冲突处理方法：

- 开放定址法
- 再哈希法
- 建立公共溢出区
- 链式地址法(拉链法)(实际工程中通常用红黑树替代链表)

__哈希表是一种极具美感的数据结构，哈希函数和冲突处理方法都没有标准答案，这就给了开发人员发挥的空间.__

传统哈希表，存储空间与元素数量强相关；布隆过滤器，存储空间与元素数量弱相关.

结构定义：

```C
typedef struct Node {
    char *s;
    struct Node *next;
} Node;

typedef struct HashTable {
    Node *data;
    int cnt, size;
} HashTable;
```

结构操作(拉链法处理冲突)：

- 创建

  ```C
  Node *getNewNode(const char *s) {
      Node *p = (Node *)malloc(sizeof(Node));
      p->s = strdup(s);
      p->next = NULL;
      return p;
  }
  
  HashTable *getNewHashTable(int n) {
      HashTable *h = (HashTable *)malloc(sizeof(HashTable));
      h->data = (Node *)malloc(sizeof(Node) * n);
      h->size = n;
      h->cnt = 0;
      return h;
  }
  ```

- 哈希函数

  ```C
  int hash_func(const char *s) {
      int seed = 131, h = 0;
      for (int i = 0; s[i]; i++) {
          h = h * seed + s[i];
      }
      return h & 0x7fffffff; // 将h强制变为正数
  } // 经典的字符串哈希函数
  ```

- 查找

  ```C
  bool find(HashTable *h, const char *s) {
      int hcode = hash_func(s), ind = hcode % h->size;
      Node *p = h->data[ind].next;
      while (p) {
          if (strcmp(p->s, s) == 0) return true;
          p = p->next;
      }
      return false;
  }
  ```

- 插入

  ```C
  bool insert(HashTable *h, const char *s) {
      if (h->cnt >= h->size * 2) {
          expand(h);    
      } 
      int hcode = hash_func(s), ind = hcode % h->size;
      Node *p = getNewNode(s);
      p->next = h->data[ind].next;
      h->data[ind].next = p;
      h->cnt += 1;
      return true;
  } // 头插法
  ```

- 扩容

  ```C
  void swapHashTable(HashTable *h1, HashTable *h2) {
      swap(h1->data, h2->data);
      swap(h1->cnt, h2->cnt);
      swap(h1->size, h2->size);
      return ;
  }
  
  void expand(HashTable *h) {
      HashTable *new_h = getNewHashTable(h->size * 2);
      for (int i = 0; i < h->size; i++) {
          Node *p = h->data[i].next;
          while (p) {
              insert(new_h, p->s);
              p = p->next;
          }
      }
      swapHashTable(h, new_h);
      clearHashTable(new_h);
      return ;
  } // 含n个元素的哈希表的扩容操作在其整个生命周期中时间复杂度约为n，则每个元素的均摊时间复杂度为O(1)
  ```

- 销毁

  ```C
  void clearNode(Node *p) {
      if (p == NULL) return ;
      if (p->s) free(p->s);
      free(p);
      return ;
  }
  
  void clearHashTable(HashTable *h) {
      if (h == NULL) return ;
      for (int i = 0; i < h->size; i++) {
          Node *p = h->data[i].next, *q;
          while (p) {
              q = p->next;
              clearNode(p);
              p = q;
          }
      }
      free(h->data);
      free(h);
      return ;
  }
  ```

#### 布隆过滤器

- 数组中只存储0或1
- 有多个哈希函数，得到数组下标后将对应位置标记为1
- 若一个元素通过所有哈希函数计算得到的数组下标对应的数组中的值均为1，则该元素__大概率__出现过
- 一个元素只要有一个哈希函数计算得到的数组下标对应的数组中的值为0，则该元素一定没有出现过

- 增大底层标注数组空间可减少误判

## 平衡树基础

### 二叉排序树

用途：解决与排名相关的检索需求。

```C
typedef struct Node {
    int key;
    struct Node *lchild, *rchild;
} Node;

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NULL;
    return p;
}

Node *insert(Node *root, int key) {
    if (root == NULL) return getNewNode(key);
    if (key == root->key) return root;
    if (key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    return root;
}

Node *predecessor(Node *root) {
    Node *temp = root->lchild;
    while (temp->rchild) temp = temp->rchild;
    return temp;
}

Node *erase(Node *root, int key) {
    if (root == NULL) return root;
    if (key < root->key) root->lchild = erase(root->lchild, key);
    else if (key > root->key) root->rchild = erase(root->rchild, key);
    else {
        if (root->lchild == NULL && root->rchild == NULL) {
            free(root);
            return NULL;
        } else if (root->lchild == NULL || root->rchild == NULL) {
            Node *temp = root->lchild ? root->lchild : root->rchild;
            free(root);
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    return root;
}

void clear(Node * root) {
    if (root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return ;
}
```

### AVL树

```C
typedef struct Node {
    int key, h;
    struct Node *lchild, *rchild;
} Node;

Node __NIL; //虚拟空结点
#define NIL (&__NIL)
__attribute__((constructor)) // 设置下面函数的属性，使其先于主函数执行
void init_NIL() {
    NIL->key = -1;
    NIL->h = 0;
    NIL->lchild = NIL->rchild = NIL;
    return ;
} 

Node  *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->h = 1;
    p->lchild = p->rchild = NIL;
    return p;
}

void update_height(Node *root) {
    H(root) = (H(L(root)) > H(R(root)) ? H(L(root)) : H(R(root))) + 1;
    return ;
}

Node *left_rotate(Node *root) {
    Node *new_node = root->rchild;
    root->rchild = new_node->lchild;
    new_node->lchild = root;
    update_height(root);
    update_height(new_node);
    return new_node;
}

Node *right_rotate(Node *root) {
    Node *new_node = root->lchild;
    root->lchild = new_node->rchild;
    new_node->rchild = root;
    update_height(root);
    update_height(new_node);
    return new_node;
}

const char *type_str[5] = {
    "",
    "maintain type : LL",
    "maintain type : LR",
    "maintain type : RR",
    "maintain type : RL",
};

Node *maintain(Node *root) {
    if (abs(H(L(root)) - H(R(root))) <= 1) return root;
    int type = 0;
    if (H(L(root)) > H(R(root))) {
        if (H(R(L(root))) > H(L(L(root)))) {
            root->lchild = left_rotate(root->lchild);
            type += 1;
        }
        root = right_rotate(root);
        type += 1;
    } else {
        type = 2;
        if (H(L(R(root))) > H(R(R(root)))) {
            root->rchild = right_rotate(root->rchild);
            type += 1;
        }
        root = left_rotate(root);
        type += 1;
    }
    printf("%s\n", type_str[type]);
    return root;
}

Node *insert(Node *root, int key) {
    if (root == NIL) return getNewNode(key);
    if (root->key == key) return root;
    if (key < root->key) root->lchild = insert(root->lchild, key);
    else root->rchild = insert(root->rchild, key);
    update_height(root);
    return maintain(root);
}

Node *erase(Node *root, int key) {
    if (root == NIL) return root;
    if (key < root->key) root->lchild = erase(root->lchild, key);
    else if (key > root->key) root->rchild = erase(root->rchild, key);
    else {
        if (root->lchild == NIL || root->rchild == NIL) { // 兼容度为0和度为1结点
            Node *temp = root->lchild != NIL ? root->lchild : root->rchild;
            free(root);
            return temp;
        } else {
            Node *temp = predecessor(root);
            root->key = temp->key;
            root->lchild = erase(root->lchild, temp->key);
        }
    }
    update_height(root);
    return maintain(root);
}
```

### 红黑树

```C
typedef struct Node {
    int key, color; // 0 : red, 1 : black, 2 : double black
    struct Node *lchild, *rchild;
} Node;
```

#### 平衡条件

- 每个结点非黑即红
- 根结点是黑色
- 叶结点(NIL)是黑色
- 如果一个结点是红色，则它的两个子结点都是黑色的
- 从根结点出发到所有叶(子)结点路径上，黑色结点数量相同

Q：红黑树中，最长路径和最短路径的关系？

A：根据平衡条件第4，5两点，最短路径，都是黑色；最长路径，红黑相间。=>最长路径是最短路径的两倍。

Q：怎么理解条件3中的NIL结点？

A：就像文章中的标点符号，虽然它不属于内容的部分，平时你也不会注意他它，可要是真没有，就会很麻烦。(无叔父时看成叔父)

__平衡调整终极法门：__

- 插入调整站在祖父结点看
- 删除调整站在父结点看
- 插入和删除的情况处理一共五种
- 调整前后每条路径上的黑色结点数量不变
- 重要推导思路：当前失衡情况有哪个结点的颜色是确定的，哪个结点的颜色是当前情况的特例，只能以颜色确定的结点去进行平衡调整

#### 插入及调整策略

Q：新插入的结点是什么颜色？

A：红色，因为插入黑色一定引发失衡，插入红色不一定引发失衡。=>插入调整即处理双红，故站在祖父结点处理。

- 情况1：叔父为红
  - 祖父黑变红
  - 父和叔父红变黑
- 情况2：叔父为黑，且祖父为LL型失衡(`LR、RR、RL`型第一步根据`AVL`树调整规则改变即可)
  - 站在祖父结点右旋
  - 二选一：
    - 红色上浮：顶端三元组变红黑黑(兼容情况1)
    - 红色下沉：顶端三元组变黑红红

```C
Node *insert_maintain(Node *root) {
    int flag = 0;
    if (C(L(root)) == RED && has_red_node(L(root))) flag = 1;
    if (C(R(root)) == RED && has_red_node(R(root))) flag = 2;
    if (flag == 0) return root;
    if (C(L(root)) == RED && C(R(root)) == RED) goto red_up_maintain;
    if (flag == 1) {
        if (C(R(L(root))) == RED) {
            L(root) = left_rorate(L(root));
        }
        root = right_rorate(root);
    } else {
        if (C(L(R(root))) == RED) {
            R(root) = right_rorate(R(root));
        }
        root = left_rorate(root);
    }
red_up_maintain:
    C(root) = RED;
    C(L(root)) = C(R(root)) = BLACK; // 红色上浮
    return root;
} // 将root结点当成祖父结点

Node *__insert(Node *root, int key){
    if (root == NIL) return getNewNode(key);
    if (key == root->key) return root;
    if (key < root->key) root->lchild = __insert(root->lchild, key);
    else root->rchild = __insert(root->rchild, key);
    return insert_maintain(root);
}

Node *insert(Node *root, int key) {
    root = __insert(root, key);
    root->color = BLACK;
    return root;
} // 保证根结点必黑
```

#### 删除及调整策略

删除调整主要是为了解决双重黑结点。

Q：删除什么样的结点会引发红黑树失衡？

A：删除度为0的黑色结点，会引发红黑树失衡，导致其对应的NIL结点变为双重黑。

- 删除红色结点
  - 度为0：直接删除
  - 度为1：不存在(平衡条件)

- 删除黑色结点
  - 度为0：解决双重黑
  - 度为1：孩子(必为红)提升取代其位置，并变黑

解决双重黑：

- 情况1：双重黑的兄弟为黑，兄弟孩子全黑
  - 父结点加一重黑
  - 自己和兄弟减一重黑
- 情况2：双重黑的兄弟为黑，兄弟同侧孩子为红(不管异侧)
  - 根据`AVL`树规则旋转(RR/LL)
  - 顶端三元组变红黑黑或全黑(由原父结点决定)
- 情况3：双重黑的兄弟为黑，兄弟同侧孩子为黑，异侧孩子为红
  - 根据`AVL`树规则(LR/RL)作第一次旋转转为情况2
  - 新根变黑，旧根变红                         
  - 实际无需修改颜色，转情况2统一修改
- 情况4：双重黑的兄弟为红
  - 右兄弟则左旋，递归到左子树处理；左兄弟则右旋，递归到右子树处理
  - 新根变黑，旧根变红，转情况1/2/3



```C
Node *erase_maintain(Node *root) {
    if (C(L(root)) != DBLACK && C(R(root)) != DBLACK) return root;
    // brother : red
    if (has_red_node(root)) {
        C(root) = RED;
        if (C(L(root)) == RED) {
            root = right_rorate(root);
            R(root) = erase_maintain(R(root));
        } else {
            root = left_rorate(root);
            L(root) = erase_maintain(L(root));
        }
        C(root) = BLACK;
        return root;
    } // 情况4
    // brother : black
    if ((C(L(root)) == DBLACK && !has_red_node(R(root))) 
        || (C(R(root)) == DBLACK && !has_red_node(L(root)))) {
        C(root) += 1;
        C(R(root)) -= 1;
        C(L(root)) -= 1;
        return root;
    } // 情况1
    if (C(R(root)) == DBLACK) {
        C(R(root)) = BLACK;
        if (C(L(L(root))) != RED) {
            L(root) = left_rorate(L(root));
        } // 情况3
        // 情况2
        C(L(root)) = C(root);
        root = right_rorate(root);
    } else {
        C(L(root)) = BLACK;
        if (C(R(R(root))) != RED) {
            R(root) = right_rorate(R(root));
        } // 情况3
        // 情况2
        C(R(root)) = C(root);
        root = left_rorate(root);
    }
    C(L(root)) = C(R(root)) = BLACK;
    return root;
}

Node *__erase(Node *root, int key) {
    if (root == NIL) return root;
    if (key < root->key) {
        L(root) =  __erase(root->lchild, key);
    } else if (key > root->key) {
        R(root) = __erase(root->rchild, key);
    } else {
        if (root->lchild == NIL || root->rchild == NIL) {
            Node *temp = root->lchild == NIL ? root->rchild : root->lchild;
            temp->color += root->color; //同时兼容三种度为0或1的情况
            free(root);
            return temp;
        } 
        Node *temp = predecessor(root);
        K(root) = K(temp);
        root->rchild = __erase(R(root), K(temp));
    }
    return erase_maintain(root);
}

Node *erase(Node *root, int key) {
    root = __erase(root, key);
    C(root) = BLACK;
    return root;
}
```

### B树

#### 结构定义

B树是一种高度平衡的树形结构，比`AVL`树结构上更优美。

一棵m阶B树，需要满足下列特性：

- 每个结点最多含有m棵子树
- 若根结点不是叶子结点，则至少有2棵子树
- 除根结点之外的所有非终端结点至少有m/2(上取整)棵子树
- 如果一个结点有n-1个关键字，则该结点有n个分支，且这n-1个关键字按照递增顺序排列
- 每个结点的结构为:（n, A<sub>0</sub>, K<sub>1</sub>, A<sub>1</sub>, K<sub>2</sub>, A<sub>2</sub>, ... , K<sub>n</sub>, A<sub>n</sub> )
- 非根结点中关键字的个数n满足:m/2 - 1(上取整) <= n <= m - 1
- 所有叶子结点处在同一层

```C
typedef struct Node {
    int n;
    int key[MAX_M + 1];
    struct Node *next[MAX_M + 1];
} Node;
```

#### 插入及调整策略

m阶B树的插入调整：

- 站在父结点处理，发生在结点关键字数量达到m时
- 核心操作是:结点分裂(中间关键字提升到父结点)

```C
Node *insert_key(Node *root, int key)  {
    if (root == NULL) {
        root = getNewNode();
        root->key[(root->n)++] = key;
        return root;
    }
    int pos = 0;
    while (pos < root->n && root->key[pos] < key) pos += 1;
    if (root->key[pos] == key) return root;
    for (int i = root->n - 1; i >= pos; i--) {
        root->key[i + 1] = root->key[i];
    }
    root->key[pos] = key;
    root->n += 1;
    return root;
}

Node *insert_maintain(Node *root, Node *child, int pos) {
    if (child->n  < MAX_M) return root;
    int spos = MAX_M / 2;
    Node *node1 = getNewNode();
    Node *node2 = getNewNode();
    node1->n = spos;
    node2->n = MAX_M - 1 - spos;
    for (int i = 0; i < spos; i++) {
        node1->key[i] = child->key[i];
        node1->next[i] = child->next[i];
    }
    node1->next[spos] = child->next[spos];
    for (int i = 0; i < node2->n; i++) {
        node2->key[i] = child->key[i + spos + 1];
        node2->next[i] = child->next[i + spos + 1];
    }
    node2->next[node2->n] = child->next[child->n];
    for (int i = root->n; i >= pos; i--) {
        root->key[i + 1] = root->key[i];
        root->next[i + 1] = root->next[i];
    }
    root->key[pos] = child->key[spos];
    root->next[pos] = node1;
    root->next[pos + 1] = node2;
    root->n += 1;
    free(child);
    return root;
}

Node *__insert(Node *root, int key) {
    if (root == NULL || root->next[0] == NULL) {
        return insert_key(root, key);
    }
    int pos = 0;
    while (pos < root->n && root->key[pos] < key) pos += 1;
    if (pos < root->n && root->key[pos] == key) return root;
    __insert(root->next[pos], key);
    return insert_maintain(root, root->next[pos], pos);
}

Node *insert(Node *root, int key) {
    root = __insert(root, key);
    if (root->n == MAX_M) {
        Node *p = getNewNode(); // 虚拟父结点
        p->next[0] = root;
        root = insert_maintain(p, root, 0);
    }
    return root;
} // 根结点性质与其他结点不同，故须封装一层处理
```

#### 删除及调整策略

- 终端结点直接删除
- 非终端结点，与前驱/后继交换再删除

m阶B树的删除调整：

- 站在父结点处理，发生在结点关键字数量为m/2 - 2(上取整)时
- 核心操作是：左旋或右旋(向兄弟借)、合并(兄弟不够借，和父结点合并)

```C
void erase_pos(Node *root, int pos) {
    for (int i = pos + 1; i < root->n; i++) {
        root->key[i - 1] = root->key[i];
    }
    root->n -= 1;
    return ;
}

void right_rotate(Node *root, int pos) {
    for (int i = RCHILD(root, pos)->n + 1; i > 0; i--) {
        RCHILD(root, pos)->key[i] = RCHILD(root, pos)->key[i - 1];
        RCHILD(root, pos)->next[i] = RCHILD(root, pos)->next[i - 1];
    }
    RCHILD(root, pos)->key[0] = root->key[pos];
    root->key[pos] = LAST_KEY(LCHILD(root, pos));
    RCHILD(root, pos)->next[0] = LAST_CHILD(LCHILD(root, pos));
    LAST_CHILD(LCHILD(root, pos)) = NULL;
    LCHILD(root, pos)->n -= 1;
    RCHILD(root, pos)->n += 1;
    return ;
}

void left_rotate(Node *root, int pos) {
    LCHILD(root, pos)->key[LCHILD(root, pos)->n] = root->key[pos];
    LCHILD(root, pos)->n += 1;
    root->key[pos] = RCHILD(root, pos)->key[0];
    LAST_CHILD(LCHILD(root, pos)) = RCHILD(root, pos)->next[0];
    for (int i = 0; i < RCHILD(root, pos)->n; i++) {
        RCHILD(root, pos)->key[i] = RCHILD(root, pos)->key[i + 1];
        RCHILD(root, pos)->next[i] = RCHILD(root, pos)->next[i + 1];
    }
    LAST_CHILD(RCHILD(root, pos)) = NULL;
    RCHILD(root, pos)->n -= 1;
    return ;
}

void merge_node(Node *root, int pos) {
    Node *node = getNewNode();
    for (int i = 0; i <= LCHILD(root, pos)->n; i++) {
        node->key[i] = LCHILD(root, pos)->key[i];
        node->next[i] = LCHILD(root, pos)->next[i];
    }
    node->n = LCHILD(root, pos)->n + 1;
    node->key[node->n - 1] = root->key[pos];
    for (int i = 0; i <= RCHILD(root, pos)->n; i++) {
        node->key[i + node->n] = RCHILD(root, pos)->key[i];
        node->next[i + node->n] = RCHILD(root, pos)->next[i];
    }
    node->n += RCHILD(root, pos)->n;
    free(LCHILD(root, pos));
    free(RCHILD(root, pos));
    for (int i = pos + 1; i <= root->n; i++) {
        root->key[i - 1] = root->key[i];
        root->next[i - 1] = root->next[i];
    }
    root->next[pos] = node;
    root->n -= 1;
    return ;
}

Node *erase_maintain(Node *root, int pos) {
    int lower_bound = (MAX_M + 1) / 2 - 1; // (MAX_M + 1) / 2下取整和MAX_M / 2上取整一样
    if (root->next[pos]->n >= lower_bound) return root;
    if (pos > 0 && root->next[pos - 1]->n > lower_bound) {
        right_rotate(root, pos - 1);
    } else if (pos < root->n && root->next[pos + 1]->n > lower_bound) {
        left_rotate(root, pos);
    } else {
        if (pos > 0) merge_node(root, pos - 1); // merge(i, j) -> (j, j + 1)
        else merge_node(root, pos);
    }
    return root;
}

Node *__erase(Node *root, int key) {
    if (root == NULL) return root;
    int pos = 0;
    while (pos < root->n && root->key[pos] < key) pos += 1;
    if (root->next[0] == NULL) {
        if (root->key[pos] == key) erase_pos(root, pos);
        return root;
    } else {
        if (pos < root->n && root->key[pos] == key) {
            Node *temp = root->next[pos];
            while (temp->next[temp->n]) temp = temp->next[temp->n];
            swap(root->key[pos], temp->key[temp->n - 1])
        }
        root->next[pos] = __erase(root->next[pos], key);
    }
    return erase_maintain(root, pos);
}

Node *erase(Node *root, int key) {
    root = __erase(root, key);
    if (root->n == 0) {
        Node *temp = root->next[0];
        free(root);
        root = temp;
    }
    return root;
} // 根结点性质与其他结点不同，故须封装一层处理
```

## 递归函数转非递归

### 系统栈模拟法

递归是一种程序设计技巧，是利用系统栈实现的，可以不利用系统栈而利用自己实现的栈实现递归函数转非递归。

- 实现递归版本
- 设计压入栈的参数
  - 递归函数运行过程中的正常参数
  - 与程序逻辑过程相关的参数(状态码，返回值相关)
- 设计状态码并实现对应逻辑
  - 将递归函数根据其各代码段拆解为对应的状态
  - 实现各状态对应的逻辑

```C
// 阶乘函数转非递归
int f(int n) {
    if (n == 1) return 1; // code : 0
    return n * f(n - 1); // code : 1
}

struct Data {
    Data(int n, int *pre_ret) : n(n), pre_ret(pre_ret) {
        code = 0;
    }
    int n;
    int code, ret, *pre_ret;
}; // code为状态码，ret为下一层函数的返回值，pre_ret为上一层函数接收返回值的变量的地址

int non_f(int n) {
    stack<Data> s;
    int ans;
    Data d(n, &ans);
    s.push(d);
    while (!s.empty()) {
        Data &cur = s.top();
        switch (cur.code) {
            case 0: {
                if (cur.n == 1) {
                    *(cur.pre_ret) = 1;
                    s.pop();
                } else {
                    cur.code = 1;
                }
            } break;
            case 1: {
                Data d(cur.n - 1, &(cur.ret));
                cur.code = 2; 
                s.push(d);
            } break;
            case 2: {
                // n * f(n - 1)
                *(cur.pre_ret) = cur.ret * cur.n;
                s.pop();
            } break;
        }
    }
    return ans;
}
```

### 拓扑序分解法

递归函数的执行过程中，可将不同的递归函数看成不同的状态，函数间相互调用的关系可看成拓扑序的先后关系，通过对程序执行图的拓扑序的拆解，按照拓扑序依次求解每个状态的值，最终即可得到正确的结果。

```C
// 归并排序转非递归
struct Data {
    Data(int l, int r) : l(l), r(r) {}
    int l, r;
};

void merge_sort_once(int *arr, int l, int r) {
    int mid = (l + r) / 2;
    int p1 = l, p2 = mid, k = l;
    while (p1 < mid || p2 < r) {
        if (p2 == r || (p1 < mid && arr[p1] <= arr[p2])) {
            buff[k++] = arr[p1++];
        } else {
            buff[k++] = arr[p2++];
        }
    }
    for (int i = l; i < r; i++) arr[i] = buff[i];
    return ;
}

void non_merge_sort(int *arr, int l, int r) {
    Data init_d(l, r);
    vector<Data> d_arr;
    d_arr.push_back(init_d);
    for (int i = 0; i < d_arr.size(); i++) {
        int ll = d_arr[i].l, rr = d_arr[i].r;
        int mid = (ll + rr) / 2;
        if (mid - ll >= 2) {
            d_arr.push_back(Data(ll, mid));
        }
        if (rr - mid >= 2) {
            d_arr.push_back(Data(mid, rr));
        }
    } // 拆解拓扑序
    for (int i = d_arr.size() - 1; i >= 0; i--) {
        merge_sort_once(arr, d_arr[i].l, d_arr[i].r);
    }
    return ;
}
```

# 进阶篇

进阶篇的学习重点不再像是基础篇中每一种算法与数据结构的细节，而是相关算法与数据结构在实际问题应用的过程中都有哪些变形。

